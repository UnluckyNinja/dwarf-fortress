From 4272b15d7e3e132ab935b87ed79e632fac2aa598 Mon Sep 17 00:00:00 2001
From: Svein Ove Aas <svein.ove@aas.no>
Date: Thu, 24 Jun 2010 23:22:46 +0200
Subject: [PATCH 02/29] Dynamically load ncurses


diff --git a/g_src/curses.h b/g_src/curses.h
index 577d325..681dbcd 100644
--- a/g_src/curses.h
+++ b/g_src/curses.h
@@ -1,3 +1,6 @@
+#ifndef DF_CURSES_H
+#define DF_CURSES_H
+
 extern "C" {
 #include "GL/glew.h"
 #ifdef unix
@@ -6,8 +9,14 @@ extern "C" {
 # undef COLOR_CYAN
 # undef COLOR_RED
 # undef COLOR_YELLOW
+# include <dlfcn.h>
 #endif
 }
 
-extern bool curses_initialized;
+extern "C" {
 void init_curses();
+  extern WINDOW **stdscr_p;
+};
+
+
+#endif
diff --git a/g_src/renderer_curses.cpp b/g_src/renderer_curses.cpp
index 72f8442..9e3c20d 100644
--- a/g_src/renderer_curses.cpp
+++ b/g_src/renderer_curses.cpp
@@ -28,7 +28,7 @@ static int charmap[256] = {
   0xB0, 0x2219, 0xB7, 0x221A, 0x207F, 0xB2, 0x25A0, 0xA0
 };
 
-bool curses_initialized = false;
+static bool curses_initialized = false;
 
 static void endwin_void() {
   if (curses_initialized) {
@@ -37,26 +37,6 @@ static void endwin_void() {
   }
 }
 
-void init_curses() {
-  // Initialize curses
-  if (!curses_initialized) {
-    curses_initialized = true;
-    initscr();
-    raw();
-    noecho();
-    keypad(stdscr, true);
-    nodelay(stdscr, true);
-    set_escdelay(25); // Possible bug
-    curs_set(0);
-    mmask_t dummy;
-    // mousemask(ALL_MOUSE_EVENTS, &dummy);
-    start_color();
-    init_pair(1, COLOR_WHITE, COLOR_BLACK);
-
-    atexit(endwin_void);
-  }
-}
-
 class renderer_curses : public renderer {
   std::map<std::pair<int,int>,int> color_pairs; // For curses. MOVEME.
 
@@ -112,12 +92,12 @@ public:
       // █ <-- Do you see gaps?
       // █
       // The color can't be bold.
-      attrset(COLOR_PAIR(pair) | A_REVERSE);
-      mvaddstr(y, x, " ");
+      wattrset(*stdscr_p, COLOR_PAIR(pair) | A_REVERSE);
+      mvwaddstr(*stdscr_p, y, x, " ");
     } else {
-      attrset(COLOR_PAIR(pair) | (bold ? A_BOLD : 0));
+      wattrset(*stdscr_p, COLOR_PAIR(pair) | (bold ? A_BOLD : 0));
       wchar_t chs[2] = {charmap[ch] ? charmap[ch] : ch,0};
-      mvaddwstr(y, x, chs);
+      mvwaddwstr(*stdscr_p, y, x, chs);
     }
   }
 
@@ -157,13 +137,13 @@ public:
 // character.  Ncurses symbols (left arrow, etc.) are returned as
 // positive values, unicode as negative. Error returns 0.
 static int getch_utf8() {
-  int byte = getch();
+  int byte = wgetch(*stdscr_p);
   if (byte == ERR) return 0;
   if (byte > 0xff) return byte;
   int len = decode_utf8_predict_length(byte);
   if (!len) return 0;
   string input(len,0); input[0] = byte;
-  for (int i = 1; i < len; i++) input[i] = getch();
+  for (int i = 1; i < len; i++) input[i] = wgetch(*stdscr_p);
   return -decode_utf8(input);
 }
 
@@ -173,7 +153,7 @@ void enablerst::eventLoop_ncurses() {
   
   while (loopvar) {
     // Check for terminal resize
-    getmaxyx(stdscr, y, x);
+    getmaxyx(*stdscr_p, y, x);
     if (y != oldy || x != oldx) {
       pause_async_loop();
       renderer->resize(x, y);
@@ -215,3 +195,155 @@ void enablerst::eventLoop_ncurses() {
     do_frame();
   }
 }
+
+
+//// libncursesw stub ////
+
+extern "C" {
+  static void *handle;
+  WINDOW **stdscr_p;
+
+  int COLOR_PAIRS;
+  static int (*_erase)(void);
+  static int (*_wmove)(WINDOW *w, int y, int x);
+  static int (*_waddnstr)(WINDOW *w, const char *s, int n);
+  static int (*_nodelay)(WINDOW *w, bool b);
+  static int (*_refresh)(void);
+  static int (*_wgetch)(WINDOW *w);
+  static int (*_endwin)(void);
+  static WINDOW *(*_initscr)(void);
+  static int (*_raw)(void);
+  static int (*_keypad)(WINDOW *w, bool b);
+  static int (*_noecho)(void);
+  static int (*_set_escdelay)(int delay);
+  static int (*_curs_set)(int s);
+  static int (*_start_color)(void);
+  static int (*_init_pair)(short p, short fg, short bg);
+  static int (*_getmouse)(MEVENT *m);
+  static int (*_waddnwstr)(WINDOW *w, const wchar_t *s, int i);
+
+  static void *dlsym_orexit(const char *symbol) {
+    void *sym = dlsym(handle, symbol);
+    if (!sym) {
+      printf("Symbol not found: %s\n", symbol);
+      exit(EXIT_FAILURE);
+    }
+    return sym;
+  }
+
+  void init_curses() {
+    static bool stub_initialized = false;
+    // Initialize the stub
+    if (!stub_initialized) {
+      stub_initialized = true;
+      // We prefer libncursesw, but we'll accept libncurses if we have to
+      handle = dlopen("libncursesw.so", RTLD_LAZY);
+      if (handle) {
+        puts("Opened libncursesw");
+      } else {
+        handle = dlopen("libncurses.so", RTLD_LAZY);
+        if (handle) {
+          puts("Fallback: Opened libncurses, output may be broken");
+          sleep(10);
+        }
+      }
+      if (!handle) {
+        puts("Unable to open any flavor of libncurses!");
+        exit(EXIT_FAILURE);
+      }
+      // Okay, look up our symbols
+      int *pairs = (int*)dlsym_orexit("COLOR_PAIRS");
+      COLOR_PAIRS = *pairs;
+      stdscr_p = (WINDOW**)dlsym_orexit("stdscr");
+      _erase = (int (*)(void))dlsym_orexit("erase");
+      _wmove = (int (*)(WINDOW *w, int y, int x))dlsym_orexit("wmove");
+      _waddnstr = (int (*)(WINDOW *w, const char *s, int n))dlsym_orexit("waddnstr");
+      _nodelay = (int (*)(WINDOW *w, bool b))dlsym_orexit("nodelay");
+      _refresh = (int (*)(void))dlsym_orexit("refresh");
+      _wgetch = (int (*)(WINDOW *w))dlsym_orexit("wgetch");
+      _endwin = (int (*)(void))dlsym_orexit("endwin");
+      _initscr = (WINDOW *(*)(void))dlsym_orexit("initscr");
+      _raw = (int (*)(void))dlsym_orexit("raw");
+      _keypad = (int (*)(WINDOW *w, bool b))dlsym_orexit("keypad");
+      _noecho = (int (*)(void))dlsym_orexit("noecho");
+      _set_escdelay = (int (*)(int delay))dlsym_orexit("set_escdelay");
+      _curs_set = (int (*)(int s))dlsym_orexit("curs_set");
+      _start_color = (int (*)(void))dlsym_orexit("start_color");
+      _init_pair = (int (*)(short p, short fg, short bg))dlsym_orexit("init_pair");
+      _getmouse = (int (*)(MEVENT *m))dlsym_orexit("getmouse");
+      _waddnwstr = (int (*)(WINDOW *w, const wchar_t *s, int i))dlsym_orexit("waddnwstr");
+    }
+    
+    // Initialize curses
+    if (!curses_initialized) {
+      curses_initialized = true;
+      initscr();
+      raw();
+      noecho();
+      keypad(*stdscr_p, true);
+      nodelay(*stdscr_p, true);
+      set_escdelay(25); // Possible bug
+      curs_set(0);
+      mmask_t dummy;
+      // mousemask(ALL_MOUSE_EVENTS, &dummy);
+      start_color();
+      init_pair(1, COLOR_WHITE, COLOR_BLACK);
+      
+      atexit(endwin_void);
+    }
+  }
+  
+  
+  int erase(void) {
+    return _erase();
+  }
+  int wmove(WINDOW *w, int y, int x) {
+    return _wmove(w, y, x);
+  }
+  int waddnstr(WINDOW *w, const char *s, int n) {
+    return _waddnstr(w, s, n);
+  }
+  int nodelay(WINDOW *w, bool b) {
+    return _nodelay(w, b);
+  }
+  int refresh(void) {
+    return _refresh();
+  }
+  int wgetch(WINDOW *w) {
+    return _wgetch(w);
+  }
+  int endwin(void) {
+    return _endwin();
+  }
+  WINDOW *initscr(void) {
+    return _initscr();
+  }
+  int raw(void) {
+    return _raw();
+  }
+  int keypad(WINDOW *w, bool b) {
+    return _keypad(w, b);
+  }
+  int noecho(void) {
+    return _noecho();
+  }
+  int set_escdelay(int delay) {
+    return _set_escdelay(delay);
+  }
+  int curs_set(int s) {
+    return _curs_set(s);
+  }
+  int start_color(void) {
+    return _start_color();
+  }
+  int init_pair(short p, short fg, short bg) {
+    return _init_pair(p, fg, bg);
+  }
+  int getmouse(MEVENT *m) {
+    return _getmouse(m);
+  }
+  int waddnwstr(WINDOW *w, const wchar_t *s, int n) {
+    return _waddnwstr(w, s, n);
+  }
+};
+
diff --git a/g_src/tetris.cpp b/g_src/tetris.cpp
index d773c3f..bb90e24 100644
--- a/g_src/tetris.cpp
+++ b/g_src/tetris.cpp
@@ -176,3 +176,7 @@ void drawborder(const char *str, char style, const char *color) {
     gps.addst(str);
   }
 }
+
+void viewscreenst::help() { }
+
+bool viewscreenst::key_conflict(InterfaceKey k) { return false; }
diff --git a/g_src/win32_compat.cpp b/g_src/win32_compat.cpp
index 6bd4ae3..44d6ace 100644
--- a/g_src/win32_compat.cpp
+++ b/g_src/win32_compat.cpp
@@ -146,16 +146,16 @@ int MessageBox(HWND *dummy, const char *text, const char *caption, UINT type)
     init_curses();
     erase();
     gps.force_full_display_count = 1;
-    attrset(A_NORMAL | COLOR_PAIR(1));
+    wattrset(*stdscr_p, A_NORMAL | COLOR_PAIR(1));
     
-    mvaddstr(0, 5, caption);
-    mvaddstr(2, 2, text);
-    nodelay(stdscr, false);
+    mvwaddstr(*stdscr_p, 0, 5, caption);
+    mvwaddstr(*stdscr_p, 2, 2, text);
+    nodelay(*stdscr_p, false);
     if (type & MB_YESNO) {
-      mvaddstr(5, 0, "Press 'y' or 'n'.");
+      mvwaddstr(*stdscr_p, 5, 0, "Press 'y' or 'n'.");
       refresh();
       while (1) {
-        char i = getch();
+        char i = wgetch(*stdscr_p);
         if (i == 'y') {
           ret = IDYES;
           break;
@@ -167,11 +167,11 @@ int MessageBox(HWND *dummy, const char *text, const char *caption, UINT type)
       }
     }
     else {
-      mvaddstr(5, 0, "Press any key to continue.");
+      mvwaddstr(*stdscr_p, 5, 0, "Press any key to continue.");
       refresh();
-      getch();
+      wgetch(*stdscr_p);
     }
-    nodelay(stdscr, -1);
+    nodelay(*stdscr_p, -1);
   }
 # endif
   
-- 
1.7.2.3

